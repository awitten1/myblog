---
title: 'When Is Linear Search Faster Than Binary Search?'
publishedAt: '2026-01-07'
summary: 'Summary goes here.'
---

There are two primary ways to search a sorted array for a given key: binary search and linear search.
You are likely aware that binary search is an `O(logn)` algorithm and linear search is an `O(n)` algorithm.
However, there are cases when for small values of `n`, when linear search is faster than binary search.
The goal of this post is to answer when and why this is the case.

The full code for this post can be found [here](https://github.com/awitten1/myblog/tree/main/code/binary-search).

## The Code

In this post we analyze the following implementations of binary search and linear search.

{
(() => {

  const code = `
  size_t binary_search(const std::vector<long>& vec, long target) {
      size_t low = 0, high = vec.size();

      while (low < high) {
          size_t mid = low + (high - low)/2;
          if (vec[mid] < target) {
              low = mid + 1;
          } else {
              high = mid;
          }
      }
      return low;
  }

  size_t linear_search(const std::vector<long>& vec, long target) {
      size_t idx = 0;
      for (; idx < vec.size(); ++idx) {
          if (vec[idx] >= target) {
              break;
          }
      }
      return idx;
  }
  `
  return (
    <SyntaxHighlighter language={"cpp"}>
    {code}
    </SyntaxHighlighter>
  )
})()
}



## Measurements

The following graph plots cycle counts on an AMD Ryzen 9 9900X (a Zen 5 CPU):

{
  (() => {
    let width = 800;
    let height = 550;
    return (
      <>
      <LinePlot height={height} width={width} yaxis={'cycles'}
        file={'/code/binary-search/results/amdzen5/cycles.csv'}
        yaxis_pretty_string={'Cycles'}
        caption={'Cycle counts on different array sizes on an AMD Zen 5 CPU'}/>

      </>
    )
  })()
}

For small arrays (fewer than 136 elements), linear search is actually faster than binary search!
This is despite the fact that binary search always executes fewer CPU instructions, as the following graph
demonstrates.

{
  (() => {
    let width = 800;
    let height = 550;
    return (
      <>
      <LinePlot height={height} width={width} yaxis={'instructions'}
        file={'/code/binary-search/results/amdzen5/cycles.csv'}
        yaxis_pretty_string={'Instructions'}
        caption={'Instruction counts on different array sizes on an AMD Zen 5 CPU'}/>
      </>
    )
  })()
}

So what is going on here? We see that despite binary search always executing fewer instructions
than linear search, binary search executes fewer Instructions Per Cycle (IPC) than linear search does.

{
  (() => {
    let width = 800;
    let height = 550;
    return (
      <>
      <LinePlot height={height} width={width} yaxis={'instructions'}
        yaxis_expr={'instructions / cycles'} yaxis_key={'ipc'}
        file={'/code/binary-search/results/amdzen5/cycles.csv'}
        yaxis_pretty_string={'IPC'}
        caption={'Instructions per cycle on different array sizes on an AMD Zen 5 CPU'}/>
      </>
    )
  })()
}


{
  (() => {
    let width = 800;
    let height = 550;
    return (
      <>
      <LinePlot height={height} width={width} yaxis={'\"branch-misses\"'}
        file={'/code/binary-search/results/amdzen5/branches.csv'}
        yaxis_pretty_string={'Branch Prediction Misses'}
        caption={'Branch prediction misses on different array sizes on an AMD Zen 5 CPU'}/>
      </>
    )
  })()
}


{
  (() => {
    let width = 800;
    let height = 550;
    return (
      <>
      <LinePlot height={height} width={width} yaxis={'cycles'}
        file={'/code/binary-search/results/amdzen2/cycles.csv'}
        yaxis_pretty_string={'Cycles'}
        caption={'Cycle counts on different array sizes on an AMD Zen 2 CPU'}/>

      </>
    )
  })()
}


{
  (() => {
    let width = 800;
    let height = 550;
    return (
      <>
      <LinePlot height={height} width={width} yaxis={'\"branch-misses\"'}
        file={'/code/binary-search/results/amdzen2/branches.csv'}
        yaxis_pretty_string={'Branch Misses'}
        caption={'Branch prediction misses on different array sizes on an AMD Zen 2 CPU'}/>
      </>
    )
  })()
}


Some random text in between.

{
  (() => {
    let width = 800;
    let height = 550;
    return (
      <LinePlot height={height} width={width} yaxis={'real_time'}
        file={'/code/binary-search/results/macbookpro/results.csv'}
        yaxis_pretty_string={'Real Time (ns)'}
        caption={'Real time different array sizes on a MacBook Pro'}/>
    )
  })()
}


